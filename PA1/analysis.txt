Sorted Array:

For the sorted arrays, I traversed through the indices that contained the point values of games. There are two pointers, one to the start of the subsection of the array (n1), and one at the end (n2). If array[n1] + array[n2] was equal to our target value, the values stored at those indices were returned, otherwise, n1 and n2 would be incremented based on the sum of the two values. If the sum was greater than the target, n2 would be decremented (because we know that the values before it will be smaller or equal), and if the sum was smaller than the target, n1 would be incremented (since the values after it will be greater than or equal). The worst-case scenario would be one where we have n inputs, and we have to do n pointer changes to find a pair. This would occur if the pair indices were in the format of {(i-1), i}, or if no valid pair was found. For each value, we check to see if it is equal to, less than, or greater than the target. This check is in constant time O(1). So, since in the worst-case scenario we would be checking all n values, the algorithm for the sorted arrays will work with O(n) operations.

Unsorted Array:

For the unsorted arrays, I used a HashSet. It stores the values of game points that do not have a compliment in the HashSet that when added equals the target value. For example, if we have a target 14 and game worth 8 points, 6 needs to be in the HashSet in order to return a valid pair, otherwise 8 is added to the HashSet. This means that for each value we check, we need to perform a HashSet look up to see if we have the desired value. Since HashSet look up works in constant time, if we have n games to check, worst case, we will do O(1) * n, which is just n. Once we’ve checked all n values, we either do or don’t have a valid pair, meaning that we only do n searches. So, the algorithm for unsorted arrays will work with O(n) operations. 

