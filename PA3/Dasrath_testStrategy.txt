For this assignment, I took a backwards approach when finding the connectivity of each network. To keep track of the unions in the system, I created an object called edges. This held the two values that would form an edge, as well as a Boolean value keeping track of whether it was marked for deletion. The last case (the network will all the deletions) was the first to be constructed. Incrementing backwards, each cycle holds the union to perform, and then an addition to the sum of connectivity. Doing it in reverse makes it easier to keep track of which elements are interconnected. I originally took on the assignment by creating a new set each time a deletion had to be made in order to avoid the issues with de-unionizing a pair, but this resulted in a drastically longer runtime. For the approach I have currently implemented, the program does not have a runtime that scales exponentially with the input size, unlike my original attempt. 