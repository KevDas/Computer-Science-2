The program is relatively simple, but the logic behind it was difficult for me to initially understand. Similar to the Knapsack problem, The largest number possible is different depending on the values available to use. The solution to n - k is not necessarily the answer to n because in some cases we are not building our answer off of previous answers. The solution is to build the biggest value possible at each step, and make a decision when moving on whether to exclude an adjacent value or to add it with its diagonal if it is larger than the number coming before hand. At any number, we are deciding whether or not it is worth it to add the current number. The two test files I generated were:411 7 4 9 3 2 5 1510 4 9 7 4 13 1 2 6 5For the first test case, the correct path to choose is 11 -> 5 -> 9. When trying to solve for a solution, both of the traditional diagonals (11 -> 2 -> 4 -> 1 & 3 -> 7 - > 5 -> 9) yield smaller answers. When finished going through the algorithm, the table will look something like this:[11, 11, 17, 25][3 , 13, 16, 18] with 25 being chosen as the largest possible number to generate. For the second, the correct path is 13 -> 9 -> 6 -> 4. A similar pattern of not taking a diagonal path occurs as well, with the final table for this test case being: [10, 17, 22, 26, 32][13, 13, 19, 28, 31] with 32 being the largest number to generate