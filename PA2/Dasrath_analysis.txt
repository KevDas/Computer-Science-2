Backtracking Problem:To analyze the time complexity of the program, I will break it up based on each of the functions.Main takes in user input has only a few things that depend on the input size:1. The time it takes for the matrix to be populated: O(M x N)2. The number of strings to read in: O(S)3. The number of times to call the findSol function: O(S)findSol creates the solution matrix (O(M x N)), prints out the characters in the word twice (O(2c)), and checks to see if the current index is the first letter of the word (O(M x N)).printSolution only really handles the printing of the solution array O(M x N).isValid solely checks values passed through and has a constant input size (O(1)).Finally, with findSolUtil, we see where the input size really scales the runtime. There are some checks based on the current index, k, that we are on as well as the recursive calls to check more indices. For the index k that we are on, there are 8 checks (1 per direction) to see if the next value is surrounding index k. Worst case, this means that for each letter k, we will call findSolUtil 8 times and perform a check, meaning that this utility will have a runtime of O(8^k). Looking at each function and their approximate runtimes, it’s clear that one element is dominant. Simplifying the equation down, we are left with an approximate runtime for the program of O(8^k), with k being the number of letters in a given word, or O(8^n).